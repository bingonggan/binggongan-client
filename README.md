## 0. 프로젝트 소개

빈공간은 물건을 포장할 때 포장 상자의 크기와 최적의 배치 방법을 제안하는 상자 포장 시뮬레이터 입니다.

사용자가 포장해야 할 물건들을 선택하면 상자 크기를 추천해주고 최대한 빈공간 없이 효율적으로 배치되는 모습을 보여줍니다. 이를 통해 사용자는 실제로 물건을 포장할 때 최적의 배치 방법을 알 수 있습니다.

## 1. 동기

## 2. 기술 스택

사용한 기술 스택은 다음과 같습니다.

- React
- Zustand
- Three.js
- fastAPI

## 3. 핵심 기능 구현 과정

이 프로젝트의 핵심은 물건들을 **빈공간 없이 효율적으로 포장**하고 **포장 상자의 크기를 추천하는 것**입니다.

### 상자에 효율적으로 물건을 포장하는 방법

물건을 빈 공간 없이 효율적으로 포장하는 문제는 3D Bin Packing Problem (3D BPP)으로 불리며, 최적의 해를 찾는 것이 매우 복잡한 **NP-hard 문제**로 정의됩니다. 이 문제를 해결하기 위해 **3D bin packing 알고리즘**을 사용했습니다.

**3D bin packing 알고리즘**은 크기, 모양, 무게가 다른 물체를 제한된 수의 3차원 컨테이너(빈)에 포장할 때, 공간 활용을 극대화하고 빈 공간을 최소화하기 위한 최적화 알고리즘입니다. 앞서 설명드린것 처럼 3D BPP는 NP-hard 문제 이기 때문에 주로 물체들을 부피에 따라 정렬하고 하나씩 배치해보는 **휴리스틱 기법**을 통해 구현됩니다.

### 프로젝트에 적합한 알고리즘 선정

이번 프로젝트에서는 다음과 같은 기준을 바탕으로 알고리즘을 선정하였습니다:

- **무게 가중치**: 무거운 물건을 바닥에 배치하는 것이 중요하기 때문에, 알고리즘이 물건의 무게를 고려할 수 있어야 합니다.
- **물건 회전**: 물건을 효율적으로 배치하기 위해 회전 가능 여부도 필수 조건입니다.

|             | jerry800416      | luisgarciar         | Online-3D-BPP-PCT    | skjolber           | 3d-bin-packing |
| ----------- | ---------------- | ------------------- | -------------------- | ------------------ | -------------- |
| 회전        | O                | X                   | O                    | X                  | X              |
| 무게 가중치 | O                | X                   | X                    | O                  | X              |
| 사용 언어   | 파이썬           | 파이썬              | 파이썬               | 자바               | 자바스크립트   |
| 비고        | 실린더 형태 가능 | OpenAI Gym API 사용 | 물건크기 입력 불가능 | three.js 예제 구현 | npm 라이브러리 |

이 기준을 바탕으로 몇 가지 알고리즘을 검토한 결과, **jerry800416** 알고리즘을 선택했습니다. jerry800416 알고리즘은 물건의 무게 가중치를 고려할 수 있을 뿐만 아니라, 물건의 **회전이 가능**하고, **실린더 형태의 물건도 처리**할 수 있습니다.

비교한 다른 알고리즘들은 각각의 장단점이 있었지만, 회전 기능이 없거나 무게 가중치를 고려하지 않는 등의 이유로 본 프로젝트의 요구사항을 충족하지 못했습니다.

### 회전 타입 정의

**jerry800416** 알고리즘은 OPTIMIZING THREE-DIMENSIONAL BIN PACKING THROUGH SIMULATION(2006) 논문을 토대로 구현되어 있습니다. 이 알고리즘을 사용하면 다음과 같은 데이터를 얻을 수 있습니다.

- 물건들의 포지션 [x축, y축, z축]
- 물건들의 회전 타입 (0~5)

물건을 정확하게 배치하기 위해 회전 타입에 대한 정의를 명확히 할 필요가 있었고, 해당 정의는 논문의 Fig.1에 명시되어 있었습니다.

<img width="344" alt="회전타입 정의" src="https://github.com/user-attachments/assets/0b5304e2-cd66-482e-aab4-8379b21e73c5">

_<center>출처: OPTIMIZING THREE-DIMENSIONAL BIN PACKING THROUGH SIMULATION(2006)</center>_

각 타입에 대한 설명은 다음과 같습니다.
|타입|회전|
|--|--|
|타입0|회전하지 않음|
|타입1|z축으로 90도 회전|
|타입2|y축으로 90도 회전|
|타입3|x축으로 90도 회전 후 y축으로 90도 회전|
|타입4|x축으로 90도 회전|
|타입5|x축으로 90도 회전 후 z축으로 90도 회전|

여기서 중요한점은 **물건을 회전시키면 포지션이 달라지기 때문에 포지션을 재조정**해야 한다는 것입니다.

예를들어 타입 1의 경우 z축으로 90도 회전하면 물건의 위치가 변경되므로 x축 좌표에 물건의 높이(h)만큼 더해줘야 물건이 원점에 정확히 위치하게 됩니다.

![회전](https://github.com/user-attachments/assets/45821993-a98b-4f9a-a279-0fc13dd7ee07)
_<center>z축으로 90도 회전 시키고</center>_

![포지션 변경](https://github.com/user-attachments/assets/097599e3-966d-4314-a10e-891d62bcfbd7)
_<center>x축 좌표에 물건의 높이(h)만큼 더한다.</center>_

<br>
이처럼 각 회전 타입에 따라 물건의 포지션과 로테이션 값을 재조정하는 표를 작성하여 물건들을 정확하게 배치할 수 있었습니다.

| 회전 타입 | 포지션(x, y, z) | 로테이션(x, y, z) |
| --------- | --------------- | ----------------- |
| 0         | [0, 0, 0]       | [0, 0, 0]         |
| 1         | [h, 0, 0]       | [0, 0, 90]        |
| 2         | [0, d, w]       | [90, 0, -90]      |
| 3         | [0, 0, w]       | [0, 90, 0]        |
| 4         | [0, 0, 0]       | [0, 90, 90]       |
| 5         | [0, d, 0]       | [90, 0, 0]        |

### 상자 크기 추천 알고리즘 구현

## 4. 개선 사항

### 내 아이템이 어디에 배치되었는지 알 수 있게 하기

사용자가 시뮬레이터 결과를 보고 실제로 물건들을 포장하기 위해선 등록한 물건이 어디에 배치되었는지 알아야 합니다.

그러나 구현된 프로젝트에선 **내 아이템**이 **어디에 배치**되었는지 알 수 없었습니다.

![일치하지 않는 내 아이템과 배치된 아이템](https://github.com/user-attachments/assets/a15a5d29-e507-49e8-8dbd-9c9bd03de7c8)
_<center>내 아이템이 어디에 배치되어 있는지 알 수 없다.</center>_

문제점을 개선하기 위해 **내 아이템을 누르면 3D 모델의 색이 변경** 되도록 하였는데요.

이 과정에서 한번 변경된 모델의 색이 다시 돌아오지 않는것을 방지하기 위해 모델을 불러올 때 기존 material을 userData에 저장시키고, 사용자가 클릭한 아이템과 모델의 index가 일치하면 material을 변경, 그렇지 않으면 기존 material을 불러오게 하여 구현하였습니다.

```javascript
modelList.map((model, index) => {
  model.scene.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      if (!child.userData.originalMaterial) {
        child.userData.originalMaterial = child.material.clone();
      }

      if (model.originalIndex == activeIndex) {
        child.material = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
        });
      } else {
        child.material = child.userData.originalMaterial;
      }
    }
  });
});
```

![모델 색 변경 구현](https://github.com/user-attachments/assets/67d2a209-1aac-496d-a7ca-335aea25f8af)
_<center>내 아이템을 클릭하면 3D모델의 색이 변경됩니다.</center>_

### 여러 상자에 물건 포장하기

### 서버 부하 테스트
